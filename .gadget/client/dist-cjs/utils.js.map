{
  "version": 3,
  "sources": ["../src/utils.ts"],
  "sourcesContent": ["/**\n * Most of these utility types are straight duplicates or refined versions of the types with the same name from api-client-core.\n * Eventually these should probably supersede the api-client-core ones.\n */\n\nimport { type FieldSelection, type VariablesOptions } from \"@gadgetinc/api-client-core\";\nimport type { FieldSelection as BuilderFieldSelection, Variable } from \"tiny-graphql-query-compiler\";\nimport { Var } from \"tiny-graphql-query-compiler\";\n\n/**\n * Allows detecting an any type, this is rather tricky:\n * The type constraint 0 extends 1 is not satisfied (0 is not assignable to 1),\n * so it should be impossible for 0 extends (1 & T) to be satisfied either, since (1 & T) should be even narrower than 1.\n * However, when T is any, it reduces 0 extends (1 & any) to 0 extends any, which is satisfied.\n * That's because any is intentionally unsound and acts as both a supertype and subtype of almost every other type.\n * source: https://stackoverflow.com/questions/49927523/disallow-call-with-any/49928360#49928360\n */\n\ntype IfAny<T, Y, N> = 0 extends 1 & T ? Y : N;\n\n/**\n * Convert a schema type into the type that a selection of it must extend\n *\n * Example Schema:\n *\n * {\n *   foo: boolean;\n *   bar?: string;\n *   nested?: {\n *     count: number\n *   }\n * }\n *\n * Example available selection:\n *\n * {\n *   foo?: boolean | null | undefined;\n *   bar?: boolean | null | undefined;\n *   nested?: {\n *     count: boolean | null | undefined\n *   }\n * }\n */\nexport type AvailableSelection<Schema> = Schema extends Array<infer T>\n  ? AvailableSelection<T>\n  : Schema extends object\n  ? { [key in keyof Schema]?: AvailableSelection<Schema[key]> }\n  : boolean | null | undefined;\n\n/**\n * Given an options object from a find method, default the type of the selection to a default if no selection is passed\n */\nexport type DefaultSelection<\n  Available extends FieldSelection,\n  Options extends { select?: Available | null },\n  Defaults extends SomeFieldsSelected<Available>\n> = IfAny<Options, Defaults, IfAny<Options[\"select\"], Defaults, Options[\"select\"] extends Available ? Options[\"select\"] : Defaults>>;\n\n/**\n * Take a FieldSelection type and construct a type with all its fields required and selected.\n */\nexport type AllFieldsSelected<Selection extends FieldSelection> = {\n  [K in keyof Selection]-?: NonNullable<Selection[K]> extends FieldSelection ? AllFieldsSelected<NonNullable<Selection[K]>> : true;\n};\n\n/**\n * Take a FieldSelection type and construct a type with its fields set to true\n * rather than (boolean | null | undefined)\n */\nexport type SomeFieldsSelected<Selection extends FieldSelection> = {\n  [K in keyof Selection]?: NonNullable<Selection[K]> extends FieldSelection ? SomeFieldsSelected<NonNullable<Selection[K]>> : true;\n};\n\n/**\n * Filter out any keys in `T` that are mapped to `never` recursively. Any nested objects that are empty after having never valued keys removed are also removed.\n *\n * ```typescript\n * type Thing = DeepFilterNever<\n *  { a: { b: never }, c: string }\n * >;  // { c: string; }\n * ```\n */\n\n/**\n * Get any keys of `Selection` that are not mapped to `never`\n */\nexport type NonNeverKeys<Selection> = {\n  [Key in keyof Selection]: Selection[Key] extends never ? never : Key;\n}[keyof Selection];\n\n/**\n * Filter out any keys in `T` that are mapped to `never`.\n */\n\nexport type FilterNever<T extends Record<string, unknown>> = NonNeverKeys<T> extends never ? never : { [Key in NonNeverKeys<T>]: T[Key] };\n\n/**\n * Filter out any keys in `T` that are mapped to `never` recursively. Any nested objects that are empty after having never valued keys removed are also removed.\n *\n * ```typescript\n * type Thing = DeepFilterNever<\n *  { a: { b: never }, c: string }\n * >;  // { c: string; }\n * ```\n */\n\nexport type DeepFilterNever<T> = T extends Record<string, unknown>\n  ? FilterNever<{\n      [Key in keyof T]: T[Key] extends Record<string, unknown> ? DeepFilterNever<T[Key]> : T[Key];\n    }>\n  : T;\n/**\n * Extract a subset of a schema given a selection\n *\n * ```typescript\n * type Selection = Select<\n *  { apple: \"red\", banana: \"yellow\", orange: \"orange\" },\n *  { apple: true, banana: false }\n * >;  // { apple: \"red\" }\n * ```\n */\n\ntype InnerSelect<Schema, Selection extends FieldSelection | null | undefined> = IfAny<\n  Selection,\n  never,\n  Selection extends null | undefined\n    ? never\n    : Schema extends (infer T)[]\n    ? InnerSelect<T, Selection>[]\n    : Schema extends null\n    ? InnerSelect<Exclude<Schema, null>, Selection> | null\n    : {\n        [Key in keyof Selection & keyof Schema]: Selection[Key] extends true\n          ? Schema[Key]\n          : Selection[Key] extends FieldSelection\n          ? InnerSelect<Schema[Key], Selection[Key]>\n          : never;\n      }\n>;\n\nexport type Select<Schema, Selection extends FieldSelection | null | undefined> = DeepFilterNever<InnerSelect<Schema, Selection>>;\n\n/**\n * Converts Selection nested object format to the tiny-graphql-query-compiler shape\n **/\nexport const fieldSelectionToQueryCompilerFields = (selection: FieldSelection, includeTypename = false): BuilderFieldSelection => {\n  const output: BuilderFieldSelection = { ...selection };\n  if (includeTypename) output.__typename = true;\n  return output;\n};\n\nexport const variableOptionsToVariables = (variables: VariablesOptions): Record<string, Variable> => {\n  return Object.fromEntries(Object.entries(variables).map(([name, options]) => [name, Var(options)]));\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA,yCAAoB;AA0Ib,MAAM,sCAAsC,CAAC,WAA2B,kBAAkB,UAAiC;AAChI,QAAM,SAAgC,EAAE,GAAG,UAAU;AACrD,MAAI;AAAiB,WAAO,aAAa;AACzC,SAAO;AACT;AAEO,MAAM,6BAA6B,CAAC,cAA0D;AACnG,SAAO,OAAO,YAAY,OAAO,QAAQ,SAAS,EAAE,IAAI,CAAC,CAAC,MAAM,OAAO,MAAM,CAAC,UAAM,wCAAI,OAAO,CAAC,CAAC,CAAC;AACpG;",
  "names": []
}
