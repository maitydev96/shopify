{"version":3,"sources":["../auth.ts"],"sourceRoot":"","sourcesContent":["import type { GadgetRecord } from \"@gadgetinc/api-client-core\";\nimport type { FastifyReply, FastifyRequest } from \"fastify\";\nimport crypto from \"node:crypto\";\nimport { FieldType, LINK_PARAM } from \"./effects\";\nimport { MisconfiguredActionError, PermissionDeniedError } from \"./errors\";\nimport { Globals } from \"./globals\";\nimport type { Session } from \"./Session\";\nimport type { AnyParams, FieldMetadata, ModelDescriptor } from \"./types\";\n\ndeclare module \"fastify\" {\n  interface FastifyRequest {\n    gadgetAuth?: {\n      redirectToSignIn: boolean;\n      signInPath: string;\n    };\n  }\n}\n\nexport const generateCode = (numBytes?: number): string => {\n  return crypto.randomBytes(numBytes ?? 64).toString(\"hex\");\n};\n\nexport const hashCode = (code: string): string => {\n  return crypto.createHash(\"sha256\").update(code).digest(\"hex\");\n};\n\nconst getSessionFromRequest = <Request extends FastifyRequest>(request: Request): Session => {\n  if (\"applicationSession\" in request) {\n    return request.applicationSession as any as Session;\n  }\n\n  throw new Error(\"The request is not a Gadget server request\");\n};\n\n/**\n * Safely compares a password reset code and hash\n * @param {string} [code] - The password reset code\n * @param {string} [hash] - The hashed password reset code\n * @returns {boolean} - Whether the code is valid or not\n */\n\n/**\n * Utility function to wrap route handlers with protection from unauthenticated requests.\n *\n * @param handler The route handler to protect\n * @param {ProtectedRouteOptions} options Options for the protected route\n * @returns handler function that is wrapped with route protection\n *\n * @example\n * ```ts\n * // routes/GET-protected-route.js\n * import { preValidation } from \"gadget-server\";\n *\n * module.exports = async ({ request, reply }) => {\n *  await reply.send(\"this is a protected route\");\n * }\n *\n * module.options = {\n *   preValidation,\n * }\n * ```\n */\nexport const preValidation = async <RouteContext extends FastifyRequest>(request: RouteContext, reply: FastifyReply): Promise<void> => {\n  let authenticated = false;\n  const applicationSession = getSessionFromRequest(request);\n  authenticated = !!applicationSession.get(\"user\");\n\n  if (!authenticated) {\n    if (request.gadgetAuth?.redirectToSignIn) {\n      await reply.redirect(request.gadgetAuth.signInPath);\n    } else {\n      await reply.status(403).send();\n    }\n  }\n};\n\nexport function validateBelongsToLink(options: {\n  input: any;\n  record: any;\n  params: AnyParams;\n  tenantId: string;\n  model: ModelDescriptor;\n  tenantModelKey: string;\n  tenantBelongsToField?: string | undefined;\n  tenantType: string;\n  tenantName?: string;\n}): void {\n  const { input, record, params, tenantId, model, tenantModelKey, tenantType, tenantBelongsToField, tenantName } = options;\n\n  // If this effect is being added to the related tenant model (Shopify Shop or Shopify Customer), simply compare the record's ID\n  if (model.key == tenantModelKey) {\n    if (record && String(record.id) !== tenantId) {\n      throw new PermissionDeniedError();\n    }\n    return;\n  }\n\n  const fieldsIsBelongsToRelatedModel = Object.values(model.fields).filter(\n    (f) => f.fieldType === (FieldType.BelongsTo as string) && f.configuration.relatedModelKey === tenantModelKey\n  );\n\n  if (fieldsIsBelongsToRelatedModel.length === 0) {\n    throw new MisconfiguredActionError(`This model is missing a related ${tenantType} field.`);\n  }\n\n  if (fieldsIsBelongsToRelatedModel.length > 1 && !tenantBelongsToField) {\n    throw new MisconfiguredActionError(\n      `This function is missing a related ${tenantType} field option. \\`${tenantType}BelongsToField\\` is a required option parameter if the model has more than one related ${tenantType} field.`\n    );\n  }\n  let relatedTenantField = fieldsIsBelongsToRelatedModel[0];\n\n  if (tenantBelongsToField) {\n    const selectedField = Object.values(model.fields).find((f) => f.apiIdentifier === tenantBelongsToField);\n    if (!selectedField) {\n      throw new MisconfiguredActionError(`The selected ${tenantType} relation field does not exist.`);\n    }\n\n    if (selectedField.fieldType !== (FieldType.BelongsTo as string) || selectedField.configuration.relatedModelKey !== tenantModelKey) {\n      throw new MisconfiguredActionError(\n        `The selected ${tenantType} relation field should be a \\`Belongs To\\` relationship to the \\`${\n          tenantName ? `${tenantName} ` : \"\"\n        }${Globals.platformModules.lodash().capitalize(tenantType)}\\` model.`\n      );\n    } else {\n      relatedTenantField = selectedField;\n    }\n  }\n\n  setBelongsToLink(input, record, params, model, relatedTenantField, tenantId);\n}\n\nexport function setBelongsToLink(\n  input: any,\n  record: GadgetRecord<any>,\n  params: AnyParams,\n  model: ModelDescriptor,\n  relatedField: FieldMetadata,\n  tenantId: string\n): void {\n  // if we're trying to set the params to a shop other than the tenant we should reject\n  if (Globals.platformModules.lodash().isObjectLike(input)) {\n    const objectInput = input as Record<string, any>;\n    if (objectInput[relatedField.apiIdentifier]) {\n      if (String(objectInput[relatedField.apiIdentifier][LINK_PARAM]) !== tenantId) {\n        throw new PermissionDeniedError();\n      }\n    } else {\n      objectInput[relatedField.apiIdentifier] = {\n        [LINK_PARAM]: tenantId,\n      };\n    }\n  } else {\n    params[model.apiIdentifier] = {\n      [relatedField.apiIdentifier]: {\n        [LINK_PARAM]: tenantId,\n      },\n    };\n  }\n\n  if (record) {\n    const value = record.getField(relatedField.apiIdentifier);\n    // if the record doesn't have a shop set then anyone can update it\n    if (value) {\n      const recordShopId = typeof value === \"object\" ? value[LINK_PARAM] : value;\n      if (String(recordShopId) !== tenantId) {\n        throw new PermissionDeniedError();\n      }\n    } else {\n      // we have to re-apply the params to the record to ensure that this still works correctly if it occurs after \"applyParams\"\n      record.setField(relatedField.apiIdentifier, {\n        [LINK_PARAM]: tenantId,\n      });\n    }\n  }\n}\n"],"names":["generateCode","hashCode","preValidation","setBelongsToLink","validateBelongsToLink","numBytes","crypto","randomBytes","toString","code","createHash","update","digest","getSessionFromRequest","request","applicationSession","Error","reply","authenticated","get","gadgetAuth","redirectToSignIn","redirect","signInPath","status","send","options","input","record","params","tenantId","model","tenantModelKey","tenantType","tenantBelongsToField","tenantName","key","String","id","PermissionDeniedError","fieldsIsBelongsToRelatedModel","Object","values","fields","filter","f","fieldType","FieldType","BelongsTo","configuration","relatedModelKey","length","MisconfiguredActionError","relatedTenantField","selectedField","find","apiIdentifier","Globals","platformModules","lodash","capitalize","relatedField","isObjectLike","objectInput","LINK_PARAM","value","getField","recordShopId","setField"],"mappings":"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"}