{"version":3,"sources":["/var/gadget/codegen/framework-1756630026360-Css7ce/src/auth.ts"],"sourcesContent":["import type { GadgetRecord } from \"@gadgetinc/api-client-core\";\nimport type { FastifyReply, FastifyRequest } from \"fastify\";\nimport crypto from \"node:crypto\";\nimport { FieldType, LINK_PARAM } from \"./effects.js\";\nimport { MisconfiguredActionError, PermissionDeniedError } from \"./errors.js\";\nimport { Globals } from \"./globals.js\";\nimport type { Session } from \"./Session.js\";\nimport type { AnyParams, FieldMetadata, ModelDescriptor } from \"./types.js\";\n\ndeclare module \"fastify\" {\n  interface FastifyRequest {\n    gadgetAuth?: {\n      redirectToSignIn: boolean;\n      signInPath: string;\n    };\n  }\n}\n\nexport const generateCode = (numBytes?: number): string => {\n  return crypto.randomBytes(numBytes ?? 64).toString(\"hex\");\n};\n\nexport const hashCode = (code: string): string => {\n  return crypto.createHash(\"sha256\").update(code).digest(\"hex\");\n};\n\nconst getSessionFromRequest = <Request extends FastifyRequest>(request: Request): Session => {\n  if (\"applicationSession\" in request) {\n    return request.applicationSession as any as Session;\n  }\n\n  throw new Error(\"The request is not a Gadget server request\");\n};\n\n/**\n * Safely compares a password reset code and hash\n * @param {string} [code] - The password reset code\n * @param {string} [hash] - The hashed password reset code\n * @returns {boolean} - Whether the code is valid or not\n */\n\n/**\n * Utility function to wrap route handlers with protection from unauthenticated requests.\n *\n * @param handler The route handler to protect\n * @param {ProtectedRouteOptions} options Options for the protected route\n * @returns handler function that is wrapped with route protection\n *\n * @example\n * ```ts\n * // routes/GET-protected-route.js\n * import { preValidation } from \"gadget-server\";\n *\n * module.exports = async ({ request, reply }) => {\n *  await reply.send(\"this is a protected route\");\n * }\n *\n * module.options = {\n *   preValidation,\n * }\n * ```\n */\nexport const preValidation = async <RouteContext extends FastifyRequest>(request: RouteContext, reply: FastifyReply): Promise<void> => {\n  let authenticated = false;\n  const applicationSession = getSessionFromRequest(request);\n  authenticated = !!applicationSession.get(\"user\");\n\n  if (!authenticated) {\n    if (request.gadgetAuth?.redirectToSignIn) {\n      await reply.redirect(request.gadgetAuth.signInPath);\n    } else {\n      await reply.status(403).send();\n    }\n  }\n};\n\nexport function validateBelongsToLink(options: {\n  input: any;\n  record: any;\n  params: AnyParams;\n  tenantId: string;\n  model: ModelDescriptor;\n  tenantModelKey: string;\n  tenantBelongsToField?: string | undefined;\n  tenantType: string;\n  tenantName?: string;\n}): void {\n  const { input, record, params, tenantId, model, tenantModelKey, tenantType, tenantBelongsToField, tenantName } = options;\n\n  // If this effect is being added to the related tenant model (Shopify Shop or Shopify Customer), simply compare the record's ID\n  if (model.key == tenantModelKey) {\n    if (record && String(record.id) !== tenantId) {\n      throw new PermissionDeniedError();\n    }\n    return;\n  }\n\n  const fieldsIsBelongsToRelatedModel = Object.values(model.fields).filter(\n    (f) => f.fieldType === (FieldType.BelongsTo as string) && f.configuration.relatedModelKey === tenantModelKey\n  );\n\n  if (fieldsIsBelongsToRelatedModel.length === 0) {\n    throw new MisconfiguredActionError(`This model is missing a related ${tenantType} field.`);\n  }\n\n  if (fieldsIsBelongsToRelatedModel.length > 1 && !tenantBelongsToField) {\n    throw new MisconfiguredActionError(\n      `This function is missing a related ${tenantType} field option. \\`${tenantType}BelongsToField\\` is a required option parameter if the model has more than one related ${tenantType} field.`\n    );\n  }\n  let relatedTenantField = fieldsIsBelongsToRelatedModel[0];\n\n  if (tenantBelongsToField) {\n    const selectedField = Object.values(model.fields).find((f) => f.apiIdentifier === tenantBelongsToField);\n    if (!selectedField) {\n      throw new MisconfiguredActionError(`The selected ${tenantType} relation field does not exist.`);\n    }\n\n    if (selectedField.fieldType !== (FieldType.BelongsTo as string) || selectedField.configuration.relatedModelKey !== tenantModelKey) {\n      throw new MisconfiguredActionError(\n        `The selected ${tenantType} relation field should be a \\`Belongs To\\` relationship to the \\`${\n          tenantName ? `${tenantName} ` : \"\"\n        }${Globals.platformModules.lodash().capitalize(tenantType)}\\` model.`\n      );\n    } else {\n      relatedTenantField = selectedField;\n    }\n  }\n\n  setBelongsToLink(input, record, params, model, relatedTenantField, tenantId);\n}\n\nexport function setBelongsToLink(\n  input: any,\n  record: GadgetRecord<any>,\n  params: AnyParams,\n  model: ModelDescriptor,\n  relatedField: FieldMetadata,\n  tenantId: string\n): void {\n  // if we're trying to set the params to a shop other than the tenant we should reject\n  if (Globals.platformModules.lodash().isObjectLike(input)) {\n    const objectInput = input as Record<string, any>;\n    if (objectInput[relatedField.apiIdentifier]) {\n      if (String(objectInput[relatedField.apiIdentifier][LINK_PARAM]) !== tenantId) {\n        throw new PermissionDeniedError();\n      }\n    } else {\n      objectInput[relatedField.apiIdentifier] = {\n        [LINK_PARAM]: tenantId,\n      };\n    }\n  } else {\n    params[model.apiIdentifier] = {\n      [relatedField.apiIdentifier]: {\n        [LINK_PARAM]: tenantId,\n      },\n    };\n  }\n\n  if (record) {\n    const value = record.getField(relatedField.apiIdentifier);\n    // if the record doesn't have a shop set then anyone can update it\n    if (value) {\n      const recordShopId = typeof value === \"object\" ? value[LINK_PARAM] : value;\n      if (String(recordShopId) !== tenantId) {\n        throw new PermissionDeniedError();\n      }\n    } else {\n      // we have to re-apply the params to the record to ensure that this still works correctly if it occurs after \"applyParams\"\n      record.setField(relatedField.apiIdentifier, {\n        [LINK_PARAM]: tenantId,\n      });\n    }\n  }\n}\n"],"names":["crypto","FieldType","LINK_PARAM","MisconfiguredActionError","PermissionDeniedError","Globals","generateCode","numBytes","randomBytes","toString","hashCode","code","createHash","update","digest","getSessionFromRequest","request","applicationSession","Error","preValidation","reply","authenticated","get","gadgetAuth","redirectToSignIn","redirect","signInPath","status","send","validateBelongsToLink","options","input","record","params","tenantId","model","tenantModelKey","tenantType","tenantBelongsToField","tenantName","key","String","id","fieldsIsBelongsToRelatedModel","Object","values","fields","filter","f","fieldType","BelongsTo","configuration","relatedModelKey","length","relatedTenantField","selectedField","find","apiIdentifier","platformModules","lodash","capitalize","setBelongsToLink","relatedField","isObjectLike","objectInput","value","getField","recordShopId","setField"],"mappings":"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"}