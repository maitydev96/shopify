{"version":3,"sources":["/var/gadget/codegen/framework-1756630026360-Css7ce/src/state-chart/index.ts"],"sourcesContent":["import { NoTransitionError } from \"../errors.js\";\nimport { Globals } from \"../globals.js\";\nimport type { StateData, StateHistoryValue, StateMapper, StateValue } from \"./StateMapper.js\";\nimport { flattenStateValue } from \"./StateMapper.js\";\n\ntype ActionContext = any;\n/**\n * Get the states we could potentially transition from given the initial state.\n *\n * Based on the state value, we have many possible states that could receive the incoming actions. For example, with the state value\n *\n *     { \"created\": { \"unfulfilled\": \"needsReview\" } } }\n *\n * we can run actions on three possible states: \"created\", \"created.unfulfilled\", and \"created.unfulfilled.needsReview\". We flatten\n * this state value into the set of state keys for each of these to create the possible transition state.\n */\n\nexport const possibleTransitionStates = ({ record, model }: ActionContext, mapper: StateMapper): StateData[] => {\n  const state = record.state;\n  if (state) {\n    const stateValue = mapper.mapApiIdentifiersToStorageValue(state);\n    return Globals.platformModules.lodash().map(flattenStateValue(stateValue), (key: string) => mapper.stateKeyToData(key));\n  } else if (model.stateChart.initialChildStateKey) {\n    const startState = mapper.stateKeyToData(model.stateChart.initialChildStateKey);\n    return [startState];\n  }\n  return [];\n};\n\n/**\n * Check if we can execute the action.\n *\n * A transition can be taken if there is a possible transition state that has the same from key as the transition we'd like to take.\n *\n * @throws {NoTransitionError} if none of the possible transition states\n */\nexport const checkCanExecute = (context: ActionContext, mapper: StateMapper): void => {\n  const receivingState = Globals.platformModules\n    .lodash()\n    .find(possibleTransitionStates(context, mapper), [\"blob.key\", context.transition.fromStateKey]);\n  if (!receivingState) {\n    const {\n      record: { state },\n    } = context;\n\n    let stateName = \"<unknown>\";\n    if (Globals.platformModules.lodash().isString(state)) {\n      stateName = state;\n    } else if (Globals.platformModules.lodash().isObjectLike(state)) {\n      stateName = JSON.stringify(state);\n    } else if (context.model.stateChart.initialChildStateKey) {\n      const initialStateKey = context.model.stateChart.initialChildStateKey;\n      const state = Globals.platformModules.lodash().find(context.model.stateChart.childStates, { key: initialStateKey });\n      if (state) {\n        stateName = state.name;\n      }\n    }\n\n    let errorMessage = `Invalid action for the ${context.model.apiIdentifier} model. Unable to execute the \"${context.action.apiIdentifier}\" action in state \"${stateName}\".`;\n    if (context.action.apiIdentifier == \"logInViaEmail\") {\n      errorMessage = `Invalid action for the ${context.model.apiIdentifier} model. This session is already logged in for ${context.params.email}.`;\n    }\n    throw new NoTransitionError(errorMessage);\n  }\n};\n\n/**\n * Incorporate a given state value into an existing historical state.\n *\n * For example, if we have the following history and state:\n *\n * ```js\n * const history = {\n *   current: \"created\",\n *   children: {\n *     created: {\n *       current: \"unfulfilled\"\n *     },\n *     archived: {\n *       current: \"softDeleted\"\n *     }\n *   }\n * };\n *\n * const state = { created: \"fulfilled\" };\n * ```\n *\n * the new historical state would be\n *\n * ```js\n * const history = {\n *   current: \"created\",\n *   children: {\n *     created: {\n *       current: \"fulfilled\"\n *     },\n *     archived: {\n *       current: \"softDeleted\"\n *     }\n *   }\n * };\n * ```\n *\n * Semantically, we set the value of \"current\" (in the history) at every point along the state value \"path\".\n */\nexport const computeStateHistory = (history: StateHistoryValue, state: StateValue): StateHistoryValue => {\n  const newHistory: StateHistoryValue = history ? Globals.platformModules.klona().klona(history) : { current: \"\" };\n  const path = [];\n  while (Globals.platformModules.lodash().isObject(state)) {\n    const [current, newState] = Object.entries(state)[0];\n\n    path.push(\"current\");\n    Globals.platformModules.lodash().set(newHistory, path, current);\n    path.pop();\n\n    path.push(\"children\");\n    path.push(current);\n\n    state = newState;\n  }\n\n  path.push(\"current\");\n  Globals.platformModules.lodash().set(newHistory, path, state);\n\n  return newHistory;\n};\n\n/**\n * Find the state value for the state we'll be transitioning into.\n *\n * For states without children, the state value will just be the state we're transitioning to.\n *\n * For states with children, we need to restore the child state from history. A historical value is used if:\n * 1. there actually is a historical value (in other words, is not `undefined`),\n * 2. the state requests history to be restored, and\n * 3. the historical value is for a nested state that actually exists.\n *\n * We recursively repeat the above. Once finished, if we're still at a state that has children, we go as deep as possible using the\n * child states that are configured to be the initial.\n */\nexport const computeStateValueFor = (history: StateHistoryValue, state: StateData, mapper: StateMapper): StateValue => {\n  // This will be the \"path\" to the penultimate state in the state value we return. For example, if the state value we\n  // return is `{ a: { b: \"c\" } }`, the path will be `[\"a\", \"b\"]`.\n  const path = Globals.platformModules.lodash().clone(state.path);\n\n  // A path to dig into the historical value. The historical value nests every state under \"children\", hence the `flatMap`.\n  const historyPath = path.flatMap((segment: string) => [\"children\", segment]);\n\n  while (state.blob.initialChildStateKey) {\n    // Rule (2) above\n    if (state.blob.restoreHistory) {\n      // The value we potentially want to restore is under the \"current\" key in the history value, so temporarily push \"current\" into the\n      // path so we can grab it, but pop it again because we may recurse further.\n      historyPath.push(\"current\");\n      const apiIdentifier = Globals.platformModules.lodash().get(history, historyPath) as string;\n      historyPath.pop();\n\n      // Rules (1) and (3) above. If there's no historical value, the `get` above will return undefined, and no child state should\n      // have an undefined API identifier, so we'll hit the break below.\n      const maybeChildState = Globals.platformModules.lodash().find(state.blob.childStates, { apiIdentifier });\n      if (maybeChildState) {\n        historyPath.push(\"children\");\n        historyPath.push(apiIdentifier);\n        path.push(apiIdentifier);\n        state = mapper.stateKeyToData(maybeChildState.key);\n        continue;\n      }\n    }\n\n    break;\n  }\n\n  path.pop();\n\n  // Now that we've went as deep into history as possible, initial the rest of the nested states with the initial states\n  while (state.blob.initialChildStateKey) {\n    path.push(state.blob.apiIdentifier);\n    state = mapper.stateKeyToData(state.blob.initialChildStateKey);\n  }\n\n  // Special case for a root state, just return the API identifier. For example, if the created state has no nested states, the\n  // actual state value will be `\"created\"`, not `{ created: ??? }`.\n  if (Globals.platformModules.lodash().isEmpty(path)) {\n    return state.apiIdentifier;\n  }\n\n  // `set` will ensure all intermediate objects are initialized. So `set({}, ['a', 'b'], 'c')` will give us `{ a: { b: \"c\" } }`\n  return Globals.platformModules.lodash().set({}, path, state.apiIdentifier);\n};\n\nexport const _doStateTransition = (\n  currentHistory: StateHistoryValue,\n  currentState: StateValue,\n  toState: StateData,\n  mapper: StateMapper,\n  record: any\n): { newState: StateValue; newHistory: StateHistoryValue } => {\n  const newHistory = computeStateHistory(currentHistory, currentState);\n\n  // It's important that we use the new history value here, instead of `recordStateHistory`, in case of a self transition. The historical\n  // value contains the position we were in _previously_. That means that if we did a self transition, we'd revert to the previous state\n  // (if it were different than the current state).\n  const newState = computeStateValueFor(newHistory, toState, mapper);\n\n  record.state = newState;\n  record.stateHistory = newHistory;\n  return { newState, newHistory };\n};\n\nexport const doStateTransition = (context: ActionContext, mapper: StateMapper): { newState: StateValue; newHistory: StateHistoryValue } => {\n  const toState = mapper.stateKeyToData(context.transition.toStateKey);\n  const currentState = Globals.platformModules.klona().klona(context.record.state);\n  const currentHistory = Globals.platformModules.klona().klona(context.record.stateHistory);\n\n  return _doStateTransition(currentHistory, currentState, toState, mapper, context.record);\n};\n\n// In case the state still hasn't been persisted, ensure the state change still happens\nexport const persistStateTransition = async (\n  newState: StateValue,\n  newHistory: StateHistoryValue,\n  context: ActionContext\n): Promise<void> => {\n  if (context.record.changed(\"state\") || context.record.changed(\"stateHistory\")) {\n    await updateState(context, newState, newHistory);\n  }\n};\n\n/** Persist the new state into the model record */\nexport const updateState = async (\n  { api, model, record, scope, logger }: ActionContext,\n  newState: StateValue,\n  stateHistory: StateHistoryValue\n): Promise<void> => {\n  if (record.id && !scope.recordDeleted) {\n    await api.internal[model.apiIdentifier].update(record.id, { [model.apiIdentifier]: { state: newState, stateHistory } });\n    logger.debug(\"updated record state\");\n  }\n};\n\nexport { isStateHistoryValue, isStateValue, StateMapper } from \"./StateMapper.js\";\nexport type { StateHistoryValue, StateValue, StateValueMap } from \"./StateMapper.js\";\n"],"names":["NoTransitionError","Globals","flattenStateValue","possibleTransitionStates","record","model","mapper","state","stateValue","mapApiIdentifiersToStorageValue","platformModules","lodash","map","key","stateKeyToData","stateChart","initialChildStateKey","startState","checkCanExecute","context","receivingState","find","transition","fromStateKey","stateName","isString","isObjectLike","JSON","stringify","initialStateKey","childStates","name","errorMessage","apiIdentifier","action","params","email","computeStateHistory","history","newHistory","klona","current","path","isObject","newState","Object","entries","push","set","pop","computeStateValueFor","clone","historyPath","flatMap","segment","blob","restoreHistory","get","maybeChildState","isEmpty","_doStateTransition","currentHistory","currentState","toState","stateHistory","doStateTransition","toStateKey","persistStateTransition","changed","updateState","api","scope","logger","id","recordDeleted","internal","update","debug","isStateHistoryValue","isStateValue","StateMapper"],"mappings":"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"}